###########################
### FUNCTIONS: Space (#208)
###########################

# Setup the MUSH object
@desc #208=It's SPAAAAACE!
-
@set #208=!SAFE NO_COMMAND
-
@wipe #208
-
@set #208=SAFE
-
&DATA #208=#351
-
&SUBFN.RESTART #208=
  think [syslog(
            SPACE,
            Rebooting GhettoSpace.  [words(get(v(data)/list.active))] active ships. 
            Cycle interval set to [default(v(data)/interval,60)] seconds.
            )];
  @dol get(v(data)/list.active)={@drain/any/all ##;@nszemit ##=[ansi(rh,WARNING:)] Space System Reboot by Admin.}; 
  @trig me/tick
-
&TICK #208=
  @dol get(v(data)/list.active)={@notify/any ##};@wait [default(v(data)/interval,60)]=@trig me/tick
-
&FN.CLASS #208=
  [ifelse(
      hasattrval(%0,space`class),
      get(%0/space`class),
      Unknown
      )]
-
&FN.ADDCONSOLE #208=
  [switch(
      [strmatch(last(lparent(%0)),get(v(data)/parent.ship))]
      [strmatch(last(lparent(%1)),get(v(data)/parent.console))],

      0?,#-1 INVALID SHIP OBJECT,
      10,#-1 INVALID CONSOLE OBJECT,
      11,[set(%1,data.ship:%0)]
         [powers(%1,api)]
         [lock(%1,=%1)]
         [set(%0,data.consoles:[trim([get(%0/data.consoles)] %1)])]
         )]
-
&FN.DISTANCE #208=
  [dist2d(
      get(%0/space`x),
      get(%0/space`y),
      get(%1/space`x),
      get(%1/space`y)
      )]
-
&FN.LAND #208=
  [switch(
      [u(fn.isship,%0)]
      [t(setr(1,locate(%0,%1,nT)))]
      [not(u(fn.isdocked,%0))]
      [and(
          eq(get(%0/space`x),get(%q1/space`x)),
          eq(get(%0/space`y),get(%q1/space`y))
          )]
      [t(hasattrval(%q1,data.landing))],

      0????,#-1 INVALID SHIP OBJECT,
      10???,#-1 INVALID TARGET OBJECT,
      110??,#-1 SHIP IS ALREADY DOCKED,
      1110?,#-1 OUT OF RANGE,
      11110,#-1 NO LANDING ZONE ON TARGET,
      11111,[u(fn.notify.ship,%0,The ship lurches as it touches down.)]
            [tel(%0,setr(2,get(%q1/data.landing)),silent)]
            [nsremit(%q2,The [ansi(wh,name(%0))] touches down in the landing area.)]
            [set(%0,data.docked:%q2)]
            [set(v(data),list.active:[remove(get(v(data)/list.active),%0)])]
            [spacesys(update.report,%0)]
            )]
-
&FN.LAUNCH #208=
  [switch(
      [u(fn.isship,%0)]
      [u(fn.isdocked,%0)]
      [hasattrval(loc(%0),space`loc)],

      0??,#-1 INVALID SHIP OBJECT,
      10?,#-1 SHIP ALREADY UNDOCKED,
      110,#-1 INVALID LANDING AREA SPACE LOC
      111,[u(fn.notify.ship,%0,The roar of the engines diminishes as the ship breaks into orbit.)]
          [nsremit(loc(%0),The [ansi(wh,name(%0))] dissapears from sight as it's propelled into orbit.)]
          [tel(%0,loc(setr(0,get(loc(%0)/space`loc))),silent)]
          [set(%0,data.docked:)]
          [set(%0,space`x:[get(%q0/space`x)])]
          [set(%0,space`y:[get(%q0/space`y)])]
          [set(v(data),list.active:[trim([get(v(data)/list.active)] %0)])]
          [u(fn.notify.consoles,%0,Launch sequence complete.)]
          [spacesys(update.report,%0)]
          )]
-
&FN.ISSHIP #208=
  [strmatch(last(lparent(%0)),get(v(data)/parent.ship))]
-
&FN.UPDATE.REPORT #208=
# %q0 = New contacts detected.
# %q1 = Contacts lost from sensors.
  [ifelse(
      [not(u(fn.isship,%0))],
      #-1 INVALID SHIP OBJECT,
      [setq(0,setdiff(setr(2,u(fn.list.report,%0)),after(setr(3,get(%0/space`report)),|)))]
      [setq(1,setdiff(after(%q3,|),%q2))]
      [iter(%q0,u(fn.notify.consoles,%0,New contact [name(itext(0))] [ansi(gh,detected)] on sensors.))]
      [iter(%q1,u(fn.notify.consoles,%0,Contact [name(itext(0))] [ansi(rh,lost)] from sensors.))]
      [set(%0,space`report:[secs()]|%q2)]
      %q2
      )]
-
&FN.LIST.REPORT #208=
  [ifelse(
      [not(u(fn.isship,%0))],
      #-1 INVALID SHIP OBJECT,
      [trim(filter(filter.inrange,remove(filter(filter.spaceobj,lcon(loc(%0))),%0)))]
      )]
-
&FILTER.SPACEOBJ #208=
  [and(
      hasattrval(%0,space`x),
      hasattrval(%0,space`y),
      not(hasattrval(%0,data.docked))
      )]
-
&FILTER.INRANGE #208=
  1
-
&FN.NOTIFY.SHIP #208=
  [nsremit(%0,%1)]
  [nszemit(%0,%1)]
-
&FN.NOTIFY.CONSOLES #208=
  iter(
    get(%0/data.consoles),
    nspemit(get(itext(0)/data.manned),[ansi(gh,>)] %1)
    )
-
# Function: console()
# Display a console's commands and their syntax
&FN.CONSOLE #208=You type the console command.
-
# Function: plot()
# Display the plot commands and their syntax
&FN.PLOT #208=You typed the plot command.
-
# Function: roster()
# Display the roster commands and their syntax
&FN.ROSTER #208=You typed the roster command.
-
# Function: shuttle()
&FN.SHUTTLE #208=You typed the shuttle command.
-
# Function: iscrew(ship DBREF, player DBREF)
# Returns true if the player is the ship's captain or a crew member
&FN.ISCREW #208=[firstof(
                    member(setr(0,get(%0/data.roster)),%1:captain),
                    member(%q0,%1:crew),
                    orflags(%1,Wr),
                    0
                    )]
-
# Function: isdocked(ship DBREF)
# Returns true if the ship is docked.
&FN.ISDOCKED #208=[t(hastype([get(%0/data.docked)],ROOM))]
-
# Function: canboard(ship DBREF, player DBREF)
# Returns true if the player can board the ship
&FN.CANBOARD #208=[or(
                    member(get(%0/data.roster),%1),
                    orflags(%1,Wr)
                    )]
-
# Function: canuseconsole(console DBREF, player DBREF)
# Returns true if the player can use the console
&FN.CANUSECONSOLE #208=
  [firstof(
        [u(#208/fn.ismanning,%0,%1)],
        [and(
            [u(#208/fn.isunmanned,%0)],
            [u(#208/fn.iscrew,%0,%1)]
            )],
        [and(
            u(fn.ismanned,%0),
            not(strmatch(loc(get(%0/data.manned)),loc(%0))),
            u(fn.iscrew,%0,%1)
            )],
        0)]
-
# Function: ismanned(console DBREF)
# Returns true if the console is manned
&FN.ISMANNED #208=[t(get(%0/data.manned))]
-
# Function: isunmanned(console DBREF)
# Returns true if the console is unmanned
&FN.ISUNMANNED #208=[not(get(%0/data.manned))]
-
# Function: ismanning(console DBREF, player DBREF)
# Returns true if the player is manning the console
&FN.ISMANNING #208=[strmatch([get(%0/data.manned)],%1)]
-
# Function: mannedby(console DBREF)
# Returns the name of the player manning the console
&FN.MANNEDBY #208=
  [ifelse(
      u(fn.ismanned,%0),
      name(get(%0/data.manned)),
      #-1 UNMANNED
      )]
-
# Subfunction: actors()
# Debug subfunction used to determine enactor, executor and caller
&SUBFN.ACTORS #208=[pemit(%#,
  /@@ Enactor name and DBREF @@/
  \%#: [name(%#)](%#) 

  /@@ Executor name and DBREF @@/
  \%!: [name(%!)](%!) 

  /@@ Caller name and DBREF @@/
  \%@: [name(%@)](%@)
)]
-
# Temporary stuff, belongs elsewhere
&FN.HICMD #208=[ansi(hu,%0)]
-
&FN.SCAN #208=
  [titlebar(Sensor Report: [name(%0)])]%r%b[ansi(y,align(2 39 21 >12,ID,Name,Class,Distance))]%r
  %b[ansi(r,--%b[repeat(-,39)]%b[repeat(-,21)]%b[repeat(-,12)])]%r
  [iter(
      setr(1,spacesys(list.report,%0)),
      %b[align(
            2 39 21 >12,
            #@,
            [name(itext(0))],
            [spacesys(class,itext(0))],
            [round(spacesys(distance,%0,itext(0)),2,1)]km
            )],
      ,%r)]%r
  [footerbar([words(%q1)] Contacts)]
  [set(%0,space`report:[secs()]|%q1)]
-

