@set #367=!safe !no_command
-
@wipe #367
-
@set #367=safe
-
@desc #367=Global space commands.
-
@lock #367==#367
-
@lock/use #367=flag^wizard|power^api
-
&data #367=#351
-
&FN.CALLER #367=
  ifelse(
      hastype(%#,thing),
      get(%#/data.manned),
      %#
      )
-
&CMD.+SPACE/LAND #367=$+space/land *=*:
  @assert [spacesys(isship,%0)]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid ship object.;
  @assert [not(spacesys(ismoving,%0))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship must come to a complete stop first.;
  @assert [t(setr(1,locate(%0,%1,nT)))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid target destination.;
  @assert [t(eq(spacesys(distance,%0,%q1),0))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Out of range.;
  @assert [hasattrval(%q1,data.landing)]=@nspemit [u(fn.caller)]=[ansi(rh,>)] No available landing platforms.;
  @assert [spacesys(isbayopen,%q1)]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The bay doors are closed.;
  @assert [nand(
              spacesys(iscapship,%0),
              spacesys(isship,%q1)
              )]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The [name(%0)] is too large to fit.;

  @nspemit [u(fn.caller)]=[ansi(gh,>)] Landing [name(%0)] on [name(%q1)].;
           think [spacesys(notify.consoles,%0,Landing sequence initiated. [ansi(yh,timestring(spacesys(cycle)))] remaining.)];
           think [spacesys(notify.ship,%0,The engines rumble as the ship prepares to land.)];
           @wait %0/space`queue`move=think [spacesys(land,%0,%q1)]
-
&CMD.+SPACE/LAUNCH #367=$+space/launch *:
  @assert [spacesys(isship,%0)]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid ship object.;
  @assert [t(hasattrval(%0,data.docked))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship is already in space.;
  @assert [not(spacesys(ismoving,%0))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship is already moving. [ansi(yh,timestring(spacesys(cycle)))] until orbit.;
  @assert [t(hasattrval(loc(%0),space`loc))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Landing zone has an invalid space loc.;
  @assert [spacesys(isbayopen,setr(Spaceloc,get(loc(%0)/space`loc)))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The bay doors are closed.;
  @assert [or(not(spacesys(isship,%q<Spaceloc>)),spacesys(isactive,%q<Spaceloc>))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] You cannot launch while the ship you're docked in is landed.;

  @nspemit [u(fn.caller)]=[ansi(gh,>)] Launching the [name(%0)].;
  think [spacesys(notify.consoles,%0,Launch sequence initiated. [ansi(yh,timestring(spacesys(cycle)))] until orbit.)];
  think [spacesys(notify.ship,%0,The ship lurches as it lifts off.)];
  think [spacesys(activate,%0)];
  @wait %0/space`queue`move=think [spacesys(launch,%0)]
-
&CMD.+SPACE/ADVANCE #367=$+space/advance *:
  @assert [spacesys(isship,setr(0,before(%0,=)))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid ship object.;
  @assert [not(hasattrval(%q0,data.docked))]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship is currently landed.;
  @assert [hasattrval(%q0,space`destination)]=@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship does not have a destination set.;
  
  @nspemit %#=[ansi(gh,>)] Advancing [name(%q0)].;
  think [setq(Ship.wasstopped,t(after(%0,=)))];
  think [setq(Ship.dest,get(%q0/space`destination))];

  think [ifelse(
                %q<Ship.wasstopped>,
                [spacesys(notify.ship,%q0,The ship lurches slightly as it accelerates.)]
                [spacesys(notify.consoles,%q0,Course engaged. Destination: %q<Ship.dest>.%r
                                              [ansi(gh,>)] Speed: [ulocal(fn.speed.parse,%q0)] [ansi(y,ETA: [spacesys(eta,%q0)])].
                                              )],
                spacesys(advance,%q0)
                )];

  @assert [hasattrval(%q0,space`destination)];
  @wait %q0/space`queue`move={+space/advance %q0}
-
&FN.SPEED.PARSE #367=
  [mul(setr(a,spacesys(speed,%0)),get(v(data)/interval))] km/h \([ansi(y,+[mul(100,sub(fdiv(%qa,spacesys(speed.base,%0)),1))]\% skill bonus)]\).
-
&CMD.+SPACE/STOP #367=$+space/stop *:
  @switch [spacesys(isship,%0)]
          [spacesys(ismoving,%0)]=

          0?,@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid ship object.,
          10,@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship is not in motion.,
          11,{@nspemit [u(fn.caller)]=[ansi(gh,>)] Stopping the [name(%0)].;
              @drain %0/space`queue`move;
              &space`destination %0=[get(%0/space`x)] [get(%0/space`y)];
              think [spacesys(advance,%0)];
              &space`destination %0
             }
-
&CMD.+SPACE/ADDCON #367=$+space/addcon *=*:
  @switch [spacesys(isship,%0)]
          [isdbref(%1)]
          [hastype(%1,thing)]=

          0??,@nspemit %#=Invalid ship object.,
          10?,@nspemit %#=Invalid console dbref.,
          110,@nspemit %#=That's not an object.,
          111,{@nspemit %#=Adding [name(%1)]\(%1\) to [name(%0)]\(%0\) as a console.;
               @parent %1=#204;
               @power %1=api;
               @power %1=pemit;
               &data.manned %1=;
               &data.ship %1=%0;
               @set %1=listen_parent;
               @set %1=monitor;
               @set %0=data.consoles:[trim([get(%0/data.consoles)] %1)];
               @lock %1==%1;
               @set %1=!no_command
              }
-
&CMD.+SPACE/JUMP #367=$+space/jump *=*:
  @switch [spacesys(isship,%0)]
          [spacesys(isjump,%1)]
          [t(hasattrval(%1,link))]
          [not(spacesys(ismoving,%0))]
          [t(eq(spacesys(distance,%0,%1),0))]=

          0????,@nspemit [u(fn.caller)]=[ansi(rh,>)] Invalid ship object.,
          10???,@nspemit [u(fn.caller)]=[ansi(rh,>)] That is not a jump point.,
          110??,@nspemit [u(fn.caller)]=[ansi(rh,>)] That jump point seems to be unlinked.,
          1110?,@nspemit [u(fn.caller)]=[ansi(rh,>)] The ship must first come to a stop.,
          11110,@nspemit [u(fn.caller)]=[ansi(rh,>)] Out of range.,
          11111,{@nspemit [u(fn.caller)]=[ansi(gh,>)] Calculating jump.;
                 think [spacesys(notify.consoles,%0,Initiating jump sequence in [ansi(yh,[spacesys(cycle)] seconds)].)];
                 @wait %0/space`queue`move=think [spacesys(jump,%0,%1)]
                }
-
&CMD.+SPACE/CLASSES #367=$+space/classes:@nspemit %#=
  [titlebar(List of Classes)]%r
  [ansi(y,align(15 6 4 4 5 5 5 5 7 5,Name,OnGrid,Cap?,Bay?,Jump?,Speed,Cargo,Armor,Shields,#Guns))]%r
  [iter(
      setr(0,lvthings(get(v(data)/bin.parents))),
      align(
          15 -6 4 4 5 5 5 5 7 -5,
          [get(itext(0)/space`class)]\([ansi(c,[itext(0)])]\),
          [words(children(itext(0)))],
          [ifelse(spacesys(iscapship,itext(0)),Yes,No)],
          [ifelse(spacesys(hasbay,itext(0)),Yes,No)],
          [ifelse(spacesys(canjump,itext(0)),Yes,No)],
          [left(num2adj(default(itext(0)/space`maxspeed,0)),5)],
          [rjust(default(itext(0)/space`cargo`max,0),5)],
          [left(num2adj(last(default(itext(0)/space`armor,0:0),:)),5)],
          [left(num2adj(last(default(itext(0)/space`shields,0:0),:)),7)],
          [first(default(itext(0)/space`guns,0|),|)]
          ),
      ,%r)]%r
  [footerbar([words(%q0)] Classes)]
-
&CMD.+SPACE/SHIPS #367=$+space/ships *:
  @switch [setr(l,pmatch(%0))]=
          #-1,@nspemit %#=Invalid player.,
          @nspemit %#=
            [titlebar(Ships belonging to [name(%ql)])]%r
            [ansi(y,align(30 15 30,Name,Class,Located in Zone))]%r
            [iter(
                 setr(s,spacesys(shipsbycaptain,%ql)),
                 align(30 15 30,
                      [name(itext(0))]\([ansi(c,[itext(0)])]\),
                      [get(itext(0)/space`class)],
                      [ifelse(
                             setr(c,zone(setr(r,room(itext(0))))),
                             [name(%qc)]\([ansi(c,%qc)]\),
                             [name(%qr)]\([ansi(c,%qr)]\)
                             )]
                      ),
                 ,%r)]%r
            [footerbar(words(%qs) Ships)]
